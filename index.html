<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="shortcut icon" href="fav.png" type="image/x-icon">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CledBoard</title>
    <!-- Core Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js`;
    </script>
    <!-- MathJax for LaTeX rendering -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
            },
            svg: {
                fontCache: 'none'
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    <!-- UI Framework -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; overscroll-behavior: none; }
        .canvas-container { border-radius: 0.5rem; touch-action: none; }
        .tool-btn, .color-btn, .slide-thumb, .pen-size-btn { transition: all 0.2s ease-in-out; }
        .tool-btn.active, .pen-size-btn.active { background-color: #3b82f6; color: white; }
        .color-btn.active { box-shadow: 0 0 0 3px #3b82f6; }
        .dark .tool-btn.active, .dark .pen-size-btn.active { background-color: #60a5fa; color: #1f2937; }
        .dark .color-btn.active { box-shadow: 0 0 0 3px #60a5fa; }
        
        #slide-container::-webkit-scrollbar { width: 8px; }
        #slide-container::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
        .dark #slide-container::-webkit-scrollbar-thumb { background: #475569; }

        .slide-thumb.active { border-color: #3b82f6; }
        .dark .slide-thumb.active { border-color: #60a5fa; }
        #stabilizer-toggle { accent-color: #3b82f6; }
        
        .modal-backdrop {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex; align-items: center; justify-content: center;
            z-index: 50; opacity: 0; pointer-events: none; transition: opacity 0.3s ease;
        }
        .modal-backdrop.visible { opacity: 1; pointer-events: auto; }
        .modal-content {
            background-color: white; border-radius: 0.5rem; padding: 1.5rem;
            transform: scale(0.95); transition: transform 0.3s ease;
        }
        .dark .modal-content { background-color: #1f2937; }
        .modal-backdrop.visible .modal-content { transform: scale(1); }
        
        .slide-thumb.dragging { opacity: 0.5; }
        .slide-thumb.drag-over { border-style: dashed; }

        #canvas-aspect-container {
            width: 100%;
            height: 100%;
            aspect-ratio: 16 / 9;
            margin: auto;
            max-width: 100%;
            max-height: 100%;
        }

        #whiteboard-canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200 overflow-hidden">
    <!-- Main App Container -->
    <div class="flex h-screen">
        <!-- Vertical Slides Bar -->
        <div class="p-2 bg-white dark:bg-gray-800 shadow-lg flex flex-col space-y-2 w-40 flex-shrink-0">
            <button id="add-slide-btn" class="p-2 rounded-md bg-blue-500 text-white hover:bg-blue-600 dark:bg-blue-600 dark:hover:bg-blue-700 flex items-center justify-center space-x-2" title="Add New Slide">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M8 12h8"/><path d="M12 8v8"/></svg>
                <span>New Slide</span>
            </button>
            <div id="slide-container" class="flex-grow flex flex-col items-center space-y-2 overflow-y-auto p-1"></div>
        </div>
        
        <!-- Main Content Area -->
        <div class="flex flex-col flex-grow min-w-0">
            <!-- Toolbar -->
            <div class="p-2 bg-white dark:bg-gray-800 shadow-md flex items-center justify-between space-x-2 flex-wrap flex-shrink-0">
                <!-- Left Tools -->
                <div class="flex items-center space-x-2 flex-wrap">
                    <button id="select-tool" class="tool-btn p-2 rounded-md hover:bg-gray-200 dark:hover:bg-gray-700" title="Select (V)"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m3 3 7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/></svg></button>
                    <button id="draw-tool" class="tool-btn p-2 rounded-md hover:bg-gray-200 dark:hover:bg-gray-700 active" title="Pencil (B)"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/></svg></button>
                    <button id="eraser-tool" class="tool-btn p-2 rounded-md hover:bg-gray-200 dark:hover:bg-gray-700" title="Eraser (E)"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20.24 7.76a4 4 0 0 0-5.66-5.66l-12 12L2 22l7.76-1.76Z"/><path d="m14 6 6 6"/><path d="M16 14H6"/></svg></button>
                    <button id="line-tool" class="tool-btn p-2 rounded-md hover:bg-gray-200 dark:hover:bg-gray-700" title="Line (L)"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="19" x2="19" y2="5"/></svg></button>
                    <button id="rect-tool" class="tool-btn p-2 rounded-md hover:bg-gray-200 dark:hover:bg-gray-700" title="Rectangle (R)"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect></svg></button>
                    <button id="circle-tool" class="tool-btn p-2 rounded-md hover:bg-gray-200 dark:hover:bg-gray-700" title="Circle (C)"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle></svg></button>
                    <button id="triangle-tool" class="tool-btn p-2 rounded-md hover:bg-gray-200 dark:hover:bg-gray-700" title="Triangle"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2L2 22h20L12 2z"/></svg></button>
                    <button id="text-tool" class="tool-btn p-2 rounded-md hover:bg-gray-200 dark:hover:bg-gray-700" title="Add Text (T)"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3v18M3 12h18"/></svg></button>
                    <button id="math-tool" class="tool-btn p-2 rounded-md hover:bg-gray-200 dark:hover:bg-gray-700" title="Insert Math (M)"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12.27 21.26a1.18 1.18 0 0 0 1.46 0C19.26 18.2 22 13.92 22 9.49A6.51 6.51 0 0 0 15.51 3a6.26 6.26 0 0 0-4.66 2.1l-.85.85-.85-.85a6.26 6.26 0 0 0-4.66-2.1A6.51 6.51 0 0 0 2 9.49c0 4.43 2.74 8.71 8.27 11.77z"/><path d="M12 7v6"/><path d="M10 9h4"/></svg></button>
                    <button id="pdf-import-tool" class="tool-btn p-2 rounded-md hover:bg-gray-200 dark:hover:bg-gray-700" title="Import PDF"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 22h14a2 2 0 0 0 2-2V7.5L14.5 2H6a2 2 0 0 0-2 2v4"/><path d="M14 2v6h6"/><path d="M2 15.5v-4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v4a2 2 0 0 1-2 2h-4a2 2 0 0 1-2-2z"/></svg></button>
                    <input type="file" id="pdf-input" class="hidden" accept="application/pdf">
                    <button id="image-tool" class="tool-btn p-2 rounded-md hover:bg-gray-200 dark:hover:bg-gray-700" title="Add Image (I)"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2"/><circle cx="9" cy="9" r="2"/><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/></svg></button>
                    <input type="file" id="image-input" class="hidden" accept="image/*">
                    <button id="delete-tool" class="tool-btn p-2 rounded-md hover:bg-red-500 hover:text-white dark:hover:bg-red-600" title="Delete (Delete/Backspace)"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6"/><path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg></button>
                </div>
                <!-- AI Tools -->
                <div class="flex items-center space-x-2 flex-wrap border-l border-gray-300 dark:border-gray-600 pl-2 ml-2">
                    <button id="explain-tool" class="tool-btn p-2 rounded-md hover:bg-purple-200 dark:hover:bg-purple-700 flex items-center space-x-1" title="✨ Explain This">
                        <span class="text-xl">✨</span> <span>Explain</span>
                    </button>
                    <button id="brainstorm-tool" class="tool-btn p-2 rounded-md hover:bg-blue-200 dark:hover:bg-blue-700 flex items-center space-x-1" title="✨ Brainstorm Ideas">
                       <span class="text-xl">✨</span> <span>Brainstorm</span>
                    </button>
                </div>
                <!-- Tool Settings -->
                <div class="flex items-center space-x-2 flex-wrap border-l border-gray-300 dark:border-gray-600 pl-2 ml-2" id="tool-settings">
                     <div class="flex items-center space-x-2"><label for="pen-size" class="text-sm">Pen:</label><input type="range" id="pen-size" min="1" max="50" value="3.5" class="w-20" title="Pen Thickness"><button class="pen-size-btn text-xs px-2 py-1 rounded bg-gray-200 dark:bg-gray-700" data-size="3.5" title="Small Pen">S</button><button class="pen-size-btn text-xs px-2 py-1 rounded bg-gray-200 dark:bg-gray-700" data-size="5" title="Medium Pen">M</button><button class="pen-size-btn text-xs px-2 py-1 rounded bg-gray-200 dark:bg-gray-700" data-size="10" title="Large Pen">L</button></div>
                    <div class="flex items-center space-x-1"><input type="checkbox" id="stabilizer-toggle" class="w-4 h-4 rounded" checked><label for="stabilizer-toggle" class="text-sm cursor-pointer" title="Smooth Drawing">Stabilizer</label></div>
                    <div class="flex items-center space-x-2"><label for="eraser-size" class="text-sm">Eraser:</label><input type="range" id="eraser-size" min="1" max="100" value="20" class="w-20" title="Eraser Thickness"></div>
                    <div class="flex items-center space-x-2" id="color-palette"></div>
                </div>
                 <!-- Right Tools -->
                <div class="flex items-center space-x-2 flex-wrap">
                    <button id="undo-btn" class="tool-btn p-2 rounded-md hover:bg-gray-200 dark:hover:bg-gray-700" title="Undo (Ctrl+Z)"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 14H6.5a3.5 3.5 0 1 1 0-7H15"/><path d="m9 17-3-3 3-3"/></svg></button>
                    <button id="redo-btn" class="tool-btn p-2 rounded-md hover:bg-gray-200 dark:hover:bg-gray-700" title="Redo (Ctrl+Y)"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 14h14.5a3.5 3.5 0 1 0 0-7H8"/><path d="m15 17 3-3-3-3"/></svg></button>
                    <button id="export-pdf-btn" class="tool-btn p-2 rounded-md hover:bg-gray-200 dark:hover:bg-gray-700" title="Export as PDF"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/><path d="M10 12v6"/><path d="m13 15-3 3-3-3"/></svg></button>
                    <button id="dark-mode-toggle" class="tool-btn p-2 rounded-md hover:bg-gray-200 dark:hover:bg-gray-700" title="Toggle Dark Mode"><svg id="moon-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="block dark:hidden"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></svg><svg id="sun-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden dark:block"><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/></svg></button>
                </div>
            </div>

            <!-- Canvas Area -->
            <div class="flex-grow p-4 min-h-0 flex items-center justify-center">
                <div id="canvas-aspect-container" class="shadow-lg rounded-lg bg-white dark:bg-gray-800">
                    <canvas id="whiteboard-canvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal for Math Input and other dialogs -->
    <div id="modal" class="modal-backdrop">
        <div class="modal-content w-full max-w-md">
            <h3 id="modal-title" class="text-lg font-medium leading-6 text-gray-900 dark:text-gray-100"></h3>
            <div id="modal-body" class="mt-2"></div>
            <div id="modal-footer" class="mt-4 flex justify-end space-x-2"></div>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- STATE MANAGEMENT ---
            let canvas;
            let currentTool = 'draw';
            let brushColor = '#000000';
            let penSize = 3.5;
            let eraserSize = 20;
            let useStabilizer = true;

            let slides = [];
            let currentSlideIndex = -1;
            let isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            
            let isDrawingShape = false;
            let shape, startPoint;
            
            let isDrawingPath = false;
            let drawingPoints = [];
            
            let draggedSlideIndex = null;

            const lightColors = ['#000000', '#EF4444', '#F97316', '#EAB308', '#22C55E', '#3B82F6', '#8B5CF6'];
            const darkColors =  ['#FFFFFF', '#FCA5A5', '#FDBA74', '#FDE047', '#86EFAC', '#93C5FD', '#C4B5FD'];
            const customProps = ['isMath', 'isShape', 'sourceData'];

            // --- INITIALIZATION ---
            function initCanvas() {
                const canvasEl = document.getElementById('whiteboard-canvas');
                const canvasContainer = document.getElementById('canvas-aspect-container');
                
                const { width, height } = canvasContainer.getBoundingClientRect();
                canvasEl.width = width;
                canvasEl.height = height;

                canvas = new fabric.Canvas(canvasEl, {
                    isDrawingMode: false,
                    backgroundColor: isDarkMode ? '#1f2937' : '#ffffff',
                });
                
                updateDrawingTool();
                setupEventListeners();
                resizeCanvas();
            }
            
            function setupEventListeners() {
                canvas.on('object:modified', () => saveState());
                canvas.on('mouse:down', handleMouseDown);
                canvas.on('mouse:move', handleMouseMove);
                canvas.on('mouse:up', handleMouseUp);
                
                const canvasContainer = canvas.getElement().parentElement;
                canvasContainer.addEventListener('pointerdown', handlePointerDown, { passive: false });
                canvasContainer.addEventListener('pointermove', handlePointerMove, { passive: false });
                canvasContainer.addEventListener('pointerup', handlePointerUp, { passive: false });
                canvasContainer.addEventListener('pointerleave', handlePointerUp, { passive: false });

                window.addEventListener('paste', handlePaste);
                window.addEventListener('resize', resizeCanvas);
            }

            function resizeCanvas() {
                saveCurrentSlideState();
                const container = document.getElementById('canvas-aspect-container');
                const { width, height } = container.getBoundingClientRect();
                
                canvas.setDimensions({ width: width, height: height });
                canvas.calcOffset();
                
                if(slides.length > 0 && slides[currentSlideIndex]) {
                    loadState(slides[currentSlideIndex].data, () => {
                        canvas.renderAll();
                    });
                }
            }
            
            function setTool(tool) {
                currentTool = tool;
                canvas.isDrawingMode = (tool === 'eraser');
                
                canvas.forEachObject(obj => {
                    obj.selectable = (tool === 'select');
                });
                
                canvas.selection = (tool === 'select');
                canvas.defaultCursor = (tool === 'draw' || tool === 'eraser') ? 'crosshair' : 'default';

                if (tool !== 'select') {
                    canvas.discardActiveObject().renderAll();
                }

                updateDrawingTool();
                document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
                const activeBtn = document.getElementById(`${tool}-tool`);
                if(activeBtn) activeBtn.classList.add('active');
            }

            function loadState(state, callback) {
                if (!state) {
                    canvas.clear();
                    canvas.setBackgroundColor(isDarkMode ? '#1f2937' : '#ffffff', canvas.renderAll.bind(canvas));
                    if (callback) callback();
                    return;
                }
                
                canvas.loadFromJSON(state, () => {
                    canvas.forEachObject(obj => {
                        if (obj.isMath && obj.sourceData) {
                             rerenderMath(obj);
                        } else {
                           obj.selectable = (currentTool === 'select');
                        }
                    });
                    canvas.renderAll();
                    if (callback) callback();
                });
            }
            
            function rerenderMath(mathObj) {
                const latex = mathObj.sourceData;
                const targetColor = mathObj.fill;

                MathJax.tex2svgPromise(latex, { display: true }).then((node) => {
                    const svgNode = node.querySelector('svg');
                    const svgData = new XMLSerializer().serializeToString(svgNode);
                    
                    fabric.loadSVGFromString(svgData, (objects, options) => {
                        objects.forEach(part => {
                           part.set({ fill: targetColor, stroke: targetColor });
                        });
                        
                        const newGroup = new fabric.Group(objects, {
                            left: mathObj.left, top: mathObj.top, originX: 'center', originY: 'center',
                            scaleX: mathObj.scaleX, scaleY: mathObj.scaleY, angle: mathObj.angle,
                            isMath: true, sourceData: latex, fill: targetColor
                        });
                        
                        canvas.remove(mathObj);
                        canvas.add(newGroup);
                        canvas.renderAll();
                    });
                });
            }

            function saveState() {
                const currentSlide = slides[currentSlideIndex];
                if (!currentSlide) return;
                if (currentSlide.historyIndex < currentSlide.history.length - 1) {
                    currentSlide.history = currentSlide.history.slice(0, currentSlide.historyIndex + 1);
                }
                currentSlide.history.push(canvas.toJSON(customProps));
                currentSlide.historyIndex++;
            }

            // --- SLIDE MANAGEMENT ---
            function initSlides() { addSlide(); }
            function addSlide(data = null, atIndex = -1) {
                const newSlideData = { history: [], historyIndex: -1, data: data || { objects: [], background: isDarkMode ? '#1f2937' : '#ffffff' } };
                if (data) { newSlideData.history.push(data); newSlideData.historyIndex = 0; }
                const insertPosition = (atIndex > -1) ? atIndex : slides.length;
                slides.splice(insertPosition, 0, newSlideData);
                // When adding a slide, force a switch to it
                const previousIndex = currentSlideIndex;
                currentSlideIndex = -1; // Force switchSlide to reload
                switchSlide(insertPosition, previousIndex);
                renderSlideThumbnails();
            }
            function saveCurrentSlideState() {
                 if (currentSlideIndex > -1 && slides[currentSlideIndex]) {
                    slides[currentSlideIndex].data = canvas.toJSON(customProps);
                }
            }
            function switchSlide(index, previousIndex = -1) {
                if (index < 0 || index >= slides.length) return;
                 // Avoid saving state if we're just re-rendering the same slide
                if (index !== previousIndex && previousIndex !== -1 && slides[previousIndex]) {
                    saveCurrentSlideState();
                }

                currentSlideIndex = index;
                const slide = slides[currentSlideIndex];
                loadState(slide.data);
                canvas.setBackgroundColor(slide.data.background || (isDarkMode ? '#1f2937' : '#ffffff'), canvas.renderAll.bind(canvas));
                if (slide.history.length === 0) { saveState(); }
                renderSlideThumbnails();
            }
            function confirmDeleteSlide(index) {
                showModal("Delete Slide", `<p>Are you sure you want to delete slide ${index + 1}?</p>`, createDialogButtons(
                    { text: 'Cancel', action: hideModal, class: 'bg-gray-200 hover:bg-gray-300 dark:bg-gray-600 dark:hover:bg-gray-500' },
                    { text: 'Delete', action: () => { deleteSlide(index); hideModal(); }, class: 'bg-red-500 text-white hover:bg-red-600' }
                ));
            }
            function createDialogButtons(...buttons) {
                const footer = document.createElement('div');
                footer.className = 'flex justify-end space-x-2';
                buttons.forEach(btnConfig => {
                    const btn = document.createElement('button');
                    btn.textContent = btnConfig.text;
                    btn.className = `px-4 py-2 rounded-md ${btnConfig.class}`;
                    btn.onclick = btnConfig.action;
                    footer.appendChild(btn);
                });
                return footer;
            }
            /**
             * NEW: Handles duplicating a slide.
             * @param {number} index The index of the slide to duplicate.
             */
            function duplicateSlide(index) {
                saveCurrentSlideState(); // Ensure the latest canvas state is saved
                const slideToCopy = slides[index];
                if (!slideToCopy) return;

                // Create a deep copy of the slide data to avoid reference issues
                const copiedData = JSON.parse(JSON.stringify(slideToCopy.data));
                addSlide(copiedData, index + 1);
            }

            /**
             * FIXED: Logic for deleting a slide to prevent errors.
             * @param {number} index The index of the slide to delete.
             */
            function deleteSlide(index) {
                if (slides.length <= 1) {
                    showModal("Cannot Delete", "<p>You cannot delete the last slide.</p>", createDialogButtons({text: 'OK', action: hideModal, class: 'bg-blue-500 text-white'}));
                    return;
                }
                
                const oldIndex = currentSlideIndex;
                slides.splice(index, 1);
                
                let newIndex = oldIndex;
                if (index < oldIndex) {
                    newIndex--; // Deleted a slide before the current one
                } else if (index === oldIndex) {
                    // Deleted the current slide, stay at this index if possible, or move back
                    newIndex = Math.min(index, slides.length - 1);
                }
                
                // Force switchSlide to run, even if the index number is the same,
                // because the content at that index has changed.
                currentSlideIndex = -1;
                switchSlide(newIndex, oldIndex);
            }
            function renderSlideThumbnails() {
                const container = document.getElementById('slide-container'); container.innerHTML = '';
                slides.forEach((slide, index) => {
                    const thumb = document.createElement('div');
                    thumb.className = `slide-thumb relative w-32 h-[72px] bg-white dark:bg-gray-700 border-2 rounded-md cursor-pointer flex-shrink-0 ${index === currentSlideIndex ? 'active' : 'border-transparent'}`;
                    thumb.title = `Slide ${index + 1}`; thumb.dataset.index = index; thumb.draggable = true;
                    
                    const thumbContent = document.createElement('div');
                    thumbContent.className = 'w-full h-full flex flex-col items-center justify-center pointer-events-none';
                    thumbContent.innerHTML = `<span class="text-lg font-bold text-gray-500 dark:text-gray-400">${index + 1}</span>`;

                    const controls = document.createElement('div');
                    controls.className = 'absolute -top-2 -right-2 flex space-x-1';

                    const duplicateBtn = document.createElement('button');
                    duplicateBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>';
                    duplicateBtn.className = 'w-5 h-5 bg-blue-500 text-white rounded-full flex items-center justify-center hover:bg-blue-700';
                    duplicateBtn.title = "Duplicate slide";
                    duplicateBtn.onclick = (e) => { e.stopPropagation(); duplicateSlide(index); };
                    
                    const deleteBtn = document.createElement('button');
                    deleteBtn.innerHTML = '&times;'; 
                    deleteBtn.className = 'w-5 h-5 bg-red-500 text-white rounded-full flex items-center justify-center text-lg leading-none hover:bg-red-700';
                    deleteBtn.title = "Delete slide"; 
                    deleteBtn.onclick = (e) => { e.stopPropagation(); confirmDeleteSlide(index); };
                    
                    controls.appendChild(duplicateBtn);
                    controls.appendChild(deleteBtn);
                    thumb.appendChild(thumbContent);
                    thumb.appendChild(controls); 
                    
                    thumb.onclick = () => switchSlide(index, currentSlideIndex);
                    thumb.addEventListener('dragstart', handleDragStart); thumb.addEventListener('dragover', handleDragOver);
                    thumb.addEventListener('dragleave', handleDragLeave); thumb.addEventListener('drop', handleDrop);
                    thumb.addEventListener('dragend', handleDragEnd);
                    container.appendChild(thumb);
                });
            }
            function handleDragStart(e) { draggedSlideIndex = parseInt(e.target.dataset.index); e.dataTransfer.effectAllowed = 'move'; e.target.classList.add('dragging'); }
            function handleDragOver(e) { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; e.target.closest('.slide-thumb').classList.add('drag-over'); }
            function handleDragLeave(e) { e.target.closest('.slide-thumb').classList.remove('drag-over'); }
            function handleDrop(e) {
                e.preventDefault(); const targetEl = e.target.closest('.slide-thumb'); targetEl.classList.remove('drag-over');
                const dropIndex = parseInt(targetEl.dataset.index);
                if (draggedSlideIndex !== dropIndex) {
                    const draggedItem = slides.splice(draggedSlideIndex, 1)[0];
                    slides.splice(dropIndex, 0, draggedItem);
                    if (currentSlideIndex === draggedSlideIndex) { currentSlideIndex = dropIndex; }
                    else if (draggedSlideIndex < currentSlideIndex && dropIndex >= currentSlideIndex) { currentSlideIndex--; }
                    else if (draggedSlideIndex > currentSlideIndex && dropIndex <= currentSlideIndex) { currentSlideIndex++; }
                    renderSlideThumbnails();
                }
            }
            function handleDragEnd(e) { e.target.classList.remove('dragging'); draggedSlideIndex = null; }

            // --- MODALS & MATH & AI ---
            function showModal(title, body, footer) { document.getElementById('modal-title').innerHTML = title; const modalBody = document.getElementById('modal-body'); modalBody.innerHTML = ''; if(typeof body === 'string') { modalBody.innerHTML = body; } else { modalBody.appendChild(body); } const footerEl = document.getElementById('modal-footer'); footerEl.innerHTML = ''; if(footer) footerEl.appendChild(footer); document.getElementById('modal').classList.add('visible'); }
            function hideModal() { document.getElementById('modal').classList.remove('visible'); }
            function showMathModal() {
                const body = `<textarea id="latex-input" class="w-full h-24 p-2 border rounded-md bg-gray-50 dark:bg-gray-700 dark:text-gray-200" placeholder="e.g., \\\\frac{-b \\\\pm \\\\sqrt{b^2-4ac}}{2a}"></textarea><div class="mt-2 p-2 border rounded-md bg-gray-100 dark:bg-gray-800" style="min-height: 60px;"><p class="text-sm text-gray-500 dark:text-gray-400">Preview:</p><div id="latex-preview" class="flex justify-center items-center py-2"></div><p id="latex-error" class="text-red-500 mt-1 text-sm"></p></div>`;
                showModal("Insert Mathematical Expression (LaTeX)", body, createDialogButtons({ text: 'Cancel', action: hideModal, class: 'bg-gray-200 hover:bg-gray-300 dark:bg-gray-600 dark:hover:bg-gray-500' },{ text: 'Insert', action: insertMath, class: 'bg-blue-500 text-white hover:bg-blue-600' }));
                const latexInput = document.getElementById('latex-input');
                latexInput.addEventListener('input', updateMathPreview); updateMathPreview(); latexInput.focus();
            }
            function updateMathPreview() {
                const latex = document.getElementById('latex-input').value; const previewEl = document.getElementById('latex-preview'); const errorEl = document.getElementById('latex-error'); errorEl.textContent = ''; if (!latex.trim()) { previewEl.innerHTML = ''; return; }
                MathJax.tex2svgPromise(latex, { display: true }).then((node) => { const svgNode = node.querySelector('svg'); svgNode.style.color = isDarkMode ? '#FFF' : '#000'; previewEl.innerHTML = ''; previewEl.appendChild(svgNode); }).catch((err) => { previewEl.innerHTML = ''; errorEl.textContent = err.message; });
            }
            function insertMath() {
                const latexInput = document.getElementById('latex-input').value; const errorEl = document.getElementById('latex-error'); if (!latexInput || errorEl.textContent) { errorEl.textContent = "Cannot insert invalid or empty math expression."; return; }
                MathJax.tex2svgPromise(latexInput, { display: true }).then(node => {
                    const svgData = new XMLSerializer().serializeToString(node.querySelector('svg'));
                    fabric.loadSVGFromString(svgData, (objects, options) => {
                        objects.forEach(obj => { if (obj.isType('path')) { obj.set({ fill: brushColor, stroke: brushColor }); } });
                        const group = new fabric.Group(objects, { left: canvas.getCenter().left, top: canvas.getCenter().top, originX: 'center', originY: 'center', isMath: true, sourceData: latexInput, fill: brushColor });
                        group.scaleToWidth(150); setTool('select'); canvas.add(group).setActiveObject(group).renderAll(); saveState(); hideModal();
                    });
                }).catch(err => { errorEl.textContent = `MathJax Error: ${err.message}`; });
            }
            async function callGeminiApi(prompt, imageData = null) {
                let chatHistory = [{ role: "user", parts: [{ text: prompt }] }]; if (imageData) { chatHistory[0].parts.push({ inlineData: { mimeType: "image/png", data: imageData } }); }
                const payload = { contents: chatHistory }; const apiKey = ""; const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                try {
                    const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (!response.ok) { throw new Error(`API request failed with status ${response.status}`); }
                    const result = await response.json();
                    if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) { return result.candidates[0].content.parts[0].text; }
                    else { throw new Error("Invalid response structure from API."); }
                } catch(error) { console.error("Gemini API call failed:", error); return `Error: Could not get a response. ${error.message}`; }
            }
            async function handleExplainTool() {
                const activeObject = canvas.getActiveObject(); if (!activeObject) { showModal("✨ Explain This", "<p>Please select an object on the canvas first.</p>", createDialogButtons({text: 'OK', action: hideModal, class: 'bg-blue-500 text-white'})); return; }
                showModal("✨ Explain This", "<p>✨ Thinking... Please wait.</p>", null);
                let prompt; let imageData = null;
                if (activeObject.isMath && activeObject.sourceData) { prompt = `Explain the following mathematical expression in a clear and concise way for a student: ${activeObject.sourceData}`; }
                else if (activeObject.type === 'i-text') { prompt = `Explain the following concept or term: "${activeObject.text}"`; }
                else { prompt = "Explain what is shown in this image. If it's a diagram, explain its components and what it represents. If it's a drawing, describe it."; imageData = activeObject.toDataURL({ format: 'png' }).split(',')[1]; }
                const explanation = await callGeminiApi(prompt, imageData);
                const explanationBody = document.createElement('div'); explanationBody.className = 'prose prose-sm dark:prose-invert max-h-96 overflow-y-auto'; explanationBody.textContent = explanation;
                showModal("✨ Explanation", explanationBody, createDialogButtons({text: 'Close', action: hideModal, class: 'bg-blue-500 text-white'}));
            }
            function showBrainstormModal() {
                const body = `<p class="text-sm mb-2 text-gray-600 dark:text-gray-400">Enter a topic and Gemini will generate ideas for you.</p><input id="brainstorm-input" class="w-full p-2 border rounded-md bg-gray-50 dark:bg-gray-700 dark:text-gray-200" placeholder="e.g., Photosynthesis, The Cold War...">`;
                showModal("✨ Brainstorm Ideas", body, createDialogButtons({ text: 'Cancel', action: hideModal, class: 'bg-gray-200 hover:bg-gray-300 dark:bg-gray-600 dark:hover:bg-gray-500' },{ text: 'Generate', action: handleBrainstorm, class: 'bg-blue-500 text-white hover:bg-blue-600' }));
                document.getElementById('brainstorm-input').focus();
            }
            async function handleBrainstorm() {
                const topic = document.getElementById('brainstorm-input').value; if (!topic.trim()) { return; }
                showModal("✨ Brainstorming", "<p>✨ Generating ideas... Please wait.</p>", null);
                const prompt = `Brainstorm a list of key concepts, ideas, or discussion points about the following topic: "${topic}". Present them as a concise bulleted list.`;
                const ideas = await callGeminiApi(prompt);
                const ideasBody = document.createElement('div'); ideasBody.className = 'prose prose-sm dark:prose-invert max-h-96 overflow-y-auto'; ideasBody.textContent = ideas;
                showModal("✨ Brainstorm Results", ideasBody, createDialogButtons({ text: 'Close', action: hideModal, class: 'bg-gray-200 hover:bg-gray-300 dark:bg-gray-600 dark:hover:bg-gray-500' },{ text: 'Insert on Canvas', action: () => insertBrainstormIdeas(ideas), class: 'bg-blue-500 text-white hover:bg-blue-600' }));
            }
            function insertBrainstormIdeas(ideas) {
                 const text = new fabric.IText(ideas.replace(/•/g, '\n•'), { left: canvas.getCenter().left, top: canvas.getCenter().top, originX: 'center', originY: 'center', fill: brushColor, fontSize: 24, fontFamily: 'Inter', padding: 10, shadow: 'rgba(0,0,0,0.3) 2px 2px 4px' });
                 canvas.add(text).setActiveObject(text).renderAll(); text.enterEditing(); saveState(); hideModal();
            }

            // --- FILE IMPORT/EXPORT ---
            async function importPDF(file) { /* ... implementation unchanged ... */ }
            function handlePaste(e) { /* ... implementation unchanged ... */ }
            
            // --- UI BINDINGS ---
            document.getElementById('select-tool').onclick = () => setTool('select');
            document.getElementById('draw-tool').onclick = () => setTool('draw');
            document.getElementById('eraser-tool').onclick = () => setTool('eraser');
            document.getElementById('line-tool').onclick = () => setTool('line');
            document.getElementById('rect-tool').onclick = () => setTool('rect');
            document.getElementById('circle-tool').onclick = () => setTool('circle');
            document.getElementById('triangle-tool').onclick = () => setTool('triangle');
            document.getElementById('text-tool').onclick = () => addText();
            document.getElementById('image-tool').onclick = () => document.getElementById('image-input').click();
            document.getElementById('image-input').onchange = (e) => { const file = e.target.files[0]; if (file) { const reader = new FileReader(); reader.onload = (event) => addImage(event.target.result); reader.readAsDataURL(file); } e.target.value = null; };
            document.getElementById('delete-tool').onclick = deleteSelected;
            document.getElementById('undo-btn').onclick = undo;
            document.getElementById('redo-btn').onclick = redo;
            document.getElementById('export-pdf-btn').onclick = exportToPDF;
            document.getElementById('dark-mode-toggle').onclick = toggleDarkMode;
            document.getElementById('add-slide-btn').onclick = () => addSlide(null, currentSlideIndex + 1);
            document.getElementById('math-tool').onclick = showMathModal;
            document.getElementById('pdf-import-tool').onclick = () => document.getElementById('pdf-input').click();
            document.getElementById('pdf-input').onchange = (e) => { const file = e.target.files[0]; if (file) { importPDF(file); } e.target.value = null; };
            document.getElementById('modal').onclick = (e) => { if (e.target.id === 'modal') hideModal(); };
            document.getElementById('explain-tool').onclick = handleExplainTool;
            document.getElementById('brainstorm-tool').onclick = showBrainstormModal;
            document.getElementById('pen-size').oninput = (e) => { penSize = e.target.value; updateDrawingTool(); };
            document.getElementById('eraser-size').oninput = (e) => { eraserSize = e.target.value; updateDrawingTool(); };
            document.querySelectorAll('.pen-size-btn').forEach(btn => { btn.onclick = (e) => { penSize = e.currentTarget.dataset.size; document.getElementById('pen-size').value = penSize; updateDrawingTool(); }; });
            document.getElementById('stabilizer-toggle').onchange = (e) => { useStabilizer = e.target.checked; };
            window.addEventListener('keydown', (e) => {
                if (document.getElementById('modal').classList.contains('visible')) { if (e.key === 'Escape') hideModal(); if (e.key === 'Enter') { if (document.getElementById('latex-input')) { e.preventDefault(); insertMath(); } if (document.getElementById('brainstorm-input')) { e.preventDefault(); handleBrainstorm(); } } return; }
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || canvas.getActiveObject()?.isEditing) return;
                if (e.ctrlKey || e.metaKey) { if (e.key === 'z') { e.preventDefault(); undo(); } else if (e.key === 'y') { e.preventDefault(); redo(); } } 
                else { switch (e.key.toLowerCase()) { case 'b': setTool('draw'); break; case 'e': setTool('eraser'); break; case 'v': setTool('select'); break; case 'l': setTool('line'); break; case 'r': setTool('rect'); break; case 'c': setTool('circle'); break; case 't': addText(); break; case 'm': showMathModal(); break; case 'i': document.getElementById('image-input').click(); break; case 'delete': case 'backspace': deleteSelected(); break; } }
            });
            function updateDrawingTool() {
                if (!canvas) return;
                document.querySelectorAll('.pen-size-btn').forEach(btn => { btn.classList.toggle('active', parseFloat(btn.dataset.size) === parseFloat(penSize)); });
                if (currentTool === 'eraser') { canvas.freeDrawingBrush.width = parseInt(eraserSize, 10); }
            }
            
            // --- NEW: ADVANCED DRAWING LOGIC FOR SMOOTH STROKES ---
            
            function handlePointerDown(e) {
                if (e.pointerType === 'mouse' && e.button !== 0) return;
                // Only handle pointer events for the drawing tool
                if (currentTool !== 'draw') return;
                e.preventDefault();
                isDrawingPath = true;
                const pointer = getPoint(e);
                drawingPoints = [{ x: pointer.x, y: pointer.y, pressure: e.pressure }];
            }

            function handlePointerMove(e) {
                if (!isDrawingPath) return;
                e.preventDefault();
                const pointer = getPoint(e);
                drawingPoints.push({ x: pointer.x, y: pointer.y, pressure: e.pressure });

                // --- FIXED: Re-enabled live preview ---
                // Get the canvas's top context for temporary drawing
                const ctx = canvas.contextTop;
                ctx.save();
                // Clear the previous preview
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.globalAlpha = 0.7; // Make the preview slightly transparent
                ctx.beginPath();
                ctx.moveTo(drawingPoints[0].x, drawingPoints[0].y);
                for(let i = 1; i < drawingPoints.length; i++) {
                    ctx.lineTo(drawingPoints[i].x, drawingPoints[i].y);
                }
                ctx.strokeStyle = brushColor;
                ctx.lineWidth = parseFloat(penSize);
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.stroke();
                ctx.restore();
            }

            function handlePointerUp(e) {
                if (!isDrawingPath) return;
                e.preventDefault();
                isDrawingPath = false;

                // --- FIXED: Clear the live preview context ---
                canvas.clearContext(canvas.contextTop);
                
                if (drawingPoints.length > 1) {
                    const path = createSmoothPath(drawingPoints);
                    if (path) {
                        canvas.add(path);
                        saveState();
                    }
                }
                drawingPoints = [];
            }

            function getPoint(e) {
                return new fabric.Point(e.offsetX, e.offsetY);
            }
            
            /**
             * NEW: Creates a smooth Fabric.Path object from a series of points
             * using quadratic bezier curves for a much less pixelated look.
             */
            function createSmoothPath(points) {
                if (points.length < 2) return null;

                // If stabilizer is off, create a simple polyline
                if (!useStabilizer) {
                     const polyline = new fabric.Polyline(points, {
                        fill: null,
                        stroke: brushColor,
                        strokeWidth: parseFloat(penSize),
                        strokeLineCap: 'round',
                        strokeLineJoin: 'round',
                        originX: 'left',
                        originY: 'top',
                        selectable: false,
                    });
                    return polyline;
                }

                // --- Smoothing logic ---
                let pathString = `M ${points[0].x} ${points[0].y}`;
                if (points.length === 2) {
                    pathString += ` L ${points[1].x} ${points[1].y}`;
                } else {
                    let midPoint = {x: (points[0].x + points[1].x)/2, y: (points[0].y + points[1].y)/2};
                    // Start with a small line to the first midpoint
                    pathString += ` L ${midPoint.x} ${midPoint.y}`;
                    
                    // Use quadratic bezier curves for the main body of the line
                    for (let i = 1; i < points.length - 1; i++) {
                        let p1 = points[i];
                        let p2 = points[i+1];
                        midPoint = {x: (p1.x + p2.x)/2, y: (p1.y + p2.y)/2};
                        pathString += ` Q ${p1.x},${p1.y} ${midPoint.x},${midPoint.y}`;
                    }
                    // End with a line to the final point
                    let lastPoint = points[points.length - 1];
                    pathString += ` L ${lastPoint.x} ${lastPoint.y}`;
                }
                
                const path = new fabric.Path(pathString, {
                    fill: null,
                    stroke: brushColor,
                    strokeWidth: parseFloat(penSize),
                    strokeLineCap: 'round',
                    strokeLineJoin: 'round',
                    originX: 'left',
                    originY: 'top',
                    selectable: false,
                });

                return path;
            }

            // --- SHAPE DRAWING LOGIC (Unchanged) ---
            function handleMouseDown(o) {
                const shapeTools = ['rect', 'circle', 'triangle', 'line'];
                if (!shapeTools.includes(currentTool) || isDrawingShape) return;
                isDrawingShape = true;
                startPoint = canvas.getPointer(o.e);
                const commonOptions = { left: startPoint.x, top: startPoint.y, originX: 'left', originY: 'top', stroke: brushColor, strokeWidth: parseInt(penSize, 10), fill: 'transparent', noScaleCache: true, selectable: false, isShape: true };
                switch(currentTool) {
                    case 'line': shape = new fabric.Line([startPoint.x, startPoint.y, startPoint.x, startPoint.y], commonOptions); break;
                    case 'rect': shape = new fabric.Rect({ ...commonOptions, width: 0, height: 0 }); break;
                    case 'circle': shape = new fabric.Ellipse({ ...commonOptions, rx: 0, ry: 0 }); break;
                    case 'triangle': shape = new fabric.Triangle({ ...commonOptions, width: 0, height: 0 }); break;
                }
                canvas.add(shape);
            }
            function handleMouseMove(o) {
                // Prevent interference with path drawing
                if (isDrawingPath) return; 
                if (!isDrawingShape || !shape) return;
                const pointer = canvas.getPointer(o.e);
                if(currentTool === 'line') { shape.set({ x2: pointer.x, y2: pointer.y }); }
                else {
                    let width = pointer.x - startPoint.x, height = pointer.y - startPoint.y;
                    shape.set({ width: Math.abs(width), height: Math.abs(height), originX: width > 0 ? 'left' : 'right', originY: height > 0 ? 'top' : 'bottom' });
                    if (currentTool === 'circle') { shape.set({ rx: Math.abs(width) / 2, ry: Math.abs(height) / 2 }); }
                }
                canvas.renderAll();
            }
            function handleMouseUp(o) {
                if(isDrawingShape) {
                    isDrawingShape = false;
                    shape.set({ selectable: (currentTool === 'select') });
                    shape.setCoords(); saveState(); shape = null;
                }
            }
            function addText() {
                setTool('select');
                const text = new fabric.IText('Double-click to edit', { left: canvas.getCenter().left, top: canvas.getCenter().top, originX: 'center', originY: 'center', fill: brushColor, fontSize: 40, fontFamily: 'Inter', padding: 5 });
                canvas.add(text).setActiveObject(text).renderAll(); text.enterEditing(); saveState();
            }
            function addImage(url) {
                setTool('select');
                fabric.Image.fromURL(url, (img) => {
                    img.scaleToWidth(canvas.width * 0.3);
                    img.set({ left: canvas.getCenter().left, top: canvas.getCenter().top, originX: 'center', originY: 'center', cornerColor: '#3B82F6', cornerSize: 10, transparentCorners: false });
                    canvas.add(img).setActiveObject(img).renderAll(); saveState();
                }, { crossOrigin: 'anonymous' });
            }

            function deleteSelected() { canvas.getActiveObjects().forEach(obj => canvas.remove(obj)); canvas.discardActiveObject().renderAll(); saveState(); }
            function undo() { const slide = slides[currentSlideIndex]; if (slide.historyIndex > 0) { slide.historyIndex--; loadState(slide.history[slide.historyIndex]); } }
            function redo() { const slide = slides[currentSlideIndex]; if (slide.historyIndex < slide.history.length - 1) { slide.historyIndex++; loadState(slide.history[slide.historyIndex]); } }
            
            function populateColorPalette() {
                const palette = document.getElementById('color-palette'); palette.innerHTML = ''; const colors = isDarkMode ? darkColors : lightColors;
                colors.forEach(color => {
                    const btn = document.createElement('button');
                    const normalizedBrushColor = new fabric.Color(brushColor).toHex().toLowerCase();
                    const normalizedBtnColor = new fabric.Color(color).toHex().toLowerCase();
                    btn.className = `color-btn w-6 h-6 rounded-full border-2 border-transparent ${normalizedBtnColor === normalizedBrushColor ? 'active' : ''}`;
                    btn.style.backgroundColor = color;
                    btn.onclick = () => {
                        brushColor = color; updateDrawingTool(); populateColorPalette();
                        const activeObjects = canvas.getActiveObjects();
                        if (activeObjects.length > 0) {
                            activeObjects.forEach(obj => {
                                if (obj.isMath) { obj.set('fill', brushColor); obj.getObjects('path').forEach(path => path.set({ fill: brushColor, stroke: brushColor })); } 
                                else if (obj.type === 'i-text') { obj.set('fill', brushColor); }
                                else if (obj.stroke) { obj.set('stroke', brushColor); }
                            });
                            canvas.renderAll(); saveState();
                        }
                    };
                    palette.appendChild(btn);
                });
            }
            async function toggleDarkMode() {
                saveCurrentSlideState();
                isDarkMode = !isDarkMode; document.documentElement.classList.toggle('dark', isDarkMode);
                const fromColors = isDarkMode ? lightColors : darkColors; const toColors = isDarkMode ? darkColors : lightColors;
                const colorMap = new Map(); fromColors.forEach((color, index) => { colorMap.set(new fabric.Color(color).toHex().toLowerCase(), toColors[index]); });
                const normalizedBrushColor = new fabric.Color(brushColor).toHex().toLowerCase(); if (colorMap.has(normalizedBrushColor)) { brushColor = colorMap.get(normalizedBrushColor); }
                showModal('Updating Theme', '<p>Applying new theme to all slides...</p>', null);
                for (const slide of slides) {
                    if (!slide.data.objects) continue;
                    slide.data.objects.forEach(obj => {
                        const processColor = (prop) => { const currentColor = obj[prop]; if (typeof currentColor === 'string' && currentColor !== 'transparent') { const normalizedColor = new fabric.Color(currentColor).toHex().toLowerCase(); if (colorMap.has(normalizedColor)) { obj[prop] = colorMap.get(normalizedColor); } } };
                        if (obj.isMath || obj.type === 'i-text' || (obj.type === 'group' && obj.isMath)) { processColor('fill'); } else { processColor('fill'); processColor('stroke'); }
                    });
                    slide.data.background = isDarkMode ? '#1f2937' : '#ffffff';
                    if (slide.historyIndex > -1 && slide.history[slide.historyIndex]) { slide.history[slide.historyIndex] = slide.data; }
                }
                const currentSlide = slides[currentSlideIndex];
                if (currentSlide) { loadState(currentSlide.data, () => { canvas.setBackgroundColor(isDarkMode ? '#1f2937' : '#ffffff', canvas.renderAll.bind(canvas)); }); }
                populateColorPalette(); updateDrawingTool(); hideModal();
            }
            async function exportToPDF() {
                const { jsPDF } = window.jspdf; saveCurrentSlideState();
                const originalWidth = canvas.width; const originalHeight = canvas.height;
                const doc = new jsPDF({ orientation: originalWidth > originalHeight ? 'landscape' : 'portrait', unit: 'px', format: [originalWidth, originalHeight] });
                showModal('Exporting PDF', `<p id="pdf-export-progress">Starting export...</p>`, null);
                for (let i = 0; i < slides.length; i++) {
                    document.getElementById('pdf-export-progress').textContent = `Processing slide ${i + 1} of ${slides.length}...`;
                    const slideData = slides[i].data; const tempCanvas = new fabric.StaticCanvas(null, { width: originalWidth, height: originalHeight });
                    await new Promise(resolve => {
                       tempCanvas.loadFromJSON(slideData, () => {
                           tempCanvas.renderAll(); const imgData = tempCanvas.toDataURL({ format: 'jpeg', quality: 0.8 });
                           if (i > 0) { doc.addPage([originalWidth, originalHeight], originalWidth > originalHeight ? 'landscape' : 'portrait'); }
                           doc.addImage(imgData, 'JPEG', 0, 0, originalWidth, originalHeight, undefined, 'FAST');
                           tempCanvas.dispose(); resolve();
                       });
                    });
                }
                doc.save('whiteboard_export.pdf'); hideModal();
            }

            // --- LET'S GO ---
            if (isDarkMode) { document.documentElement.classList.add('dark'); brushColor = '#FFFFFF'; }
            initCanvas(); initSlides(); setTool('draw'); populateColorPalette();
        });
    </script>
</body>
</html>
